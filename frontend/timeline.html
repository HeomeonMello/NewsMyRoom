<script>
  var $ = window.parent.$;
  var loess = science.stats.loess();
  var yaxislab = "Proportional volume (%)";
  if (window.parent.query.timelinemode == 'TimelineTone') { yaxislab = "Average tone"; }
  var datasets = window.parent.datasets;

  // Reformat GDELT JSON for crossfilter
  function format_gdelt(x) {
    var out = [];
    var k = Object.keys(x);
    for (var i = 0; i < k.length; i++) {
      var d = x[k[i]].data.timeline[0].data;
      grpsizes[k[i]] = d.length;
      for (var j = 0; j < d.length; j++) {
        var ds = d[j].date; // Date string
        var dt = new Date(ds.substr(0, 4), ds.substr(4, 2) - 1, ds.substr(6, 2));
        var p = { "name": k[i], "date": dt, "value": d[j].value };
        out.push(p);
      }
    }
    return out;
  }

  var grpsizes = {};
  var gdelt = format_gdelt(datasets);
  var dat = crossfilter(gdelt);

  var mindate = Infinity, maxdate = -Infinity;
  gdelt.forEach(d => {
    if (d.date < mindate) mindate = d.date;
    if (d.date > maxdate) maxdate = d.date;
  });
  if (mindate === Infinity) mindate = new Date();
  if (maxdate === -Infinity) maxdate = new Date();

  var xvals = gdelt.map(d => d.date.getTime());
  var yvals = gdelt.map(d => d.value);
  loess.bandwidth(0.5);
  var yvals_smooth = loess(xvals, yvals);

  var typeSeriesDimension = dat.dimension(d => [d.name, d.date]);
  var totalGroup = typeSeriesDimension.group().reduceSum(d => d.value);
  var typeDimension2 = dat.dimension(d => d.name);
  var typeGroupTotal = typeDimension2.group().reduceSum(d => d.value / grpsizes[d.name]);

  function plot() {
    var w = window.innerWidth * 0.98;
    var h = window.innerHeight * 0.98;
    var h_bars = 0.075 + (Object.keys(grpsizes).length * 0.033);
    var h_sers = 1 - h_bars;

    dc.seriesChart("#series-chart")
            .chart(c => dc.lineChart(c))
            .width(w)
            .height(h * h_sers)
            .x(d3.time.scale().domain([mindate, maxdate]))
            .yAxisLabel(yaxislab)
            .clipPadding(10)
            .elasticY(true)
            .dimension(typeSeriesDimension)
            .group(totalGroup)
            .seriesAccessor(d => d.key[0])
            .keyAccessor(d => d.key[1])
            .valueAccessor(d => d.value)
            .legend(dc.legend().x(w * 0.8).y(10).itemHeight(23).gap(5));

    dc.rowChart("#row-chart")
            .width(w)
            .height(h * h_bars)
            .dimension(typeDimension2)
            .group(typeGroupTotal);

    dc.renderAll();
  }

  plot();

  $(window).resize(() => {
    clearTimeout(resize_timeout);
    resize_timeout = setTimeout(() => {
      plot();
    }, 500);
  });

  // Download links
  var data = "text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(datasets));
  var jsonlink = document.getElementById('data_lnk');
  jsonlink.insertAdjacentHTML('beforeend', '<a class="data_link" href="data:' + data + '" download="data.json">JSON</a>');

  var datakeys = Object.keys(datasets);
  var csv = "data:text/csv;charset=utf-8," + 'query,url,\r\n';
  datakeys.forEach(key => {
    csv += key + ',' + datasets[key].url + ',\r\n';
  });
  csv += '\r\nquery,date,value\r\n';
  datakeys.forEach(key => {
    var d = datasets[key].data.timeline[0].data;
    d.forEach(item => {
      csv += `${key},${item.date},${item.value}\r\n`;
    });
  });
  var encodedUri = encodeURI(csv);
  jsonlink.insertAdjacentHTML('beforeend', '<a class="data_link" href="' + encodedUri + '" download="data.csv">CSV</a>');
</script>
